n:=6;
betas:=[2.72176627];
gammas:=[0.35475932];

n_graph_edges:=7;
graph:=[[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [0, 4], [5,1]];

def QAOA[n:!‚Ñï](const g_edges:!‚Ñï[][],  const betas:!‚Ñù[], const gammas:!‚Ñù[]) mfree
{
    // Prepare initial state of |0...0>
    x:=vector(n,0:ùîπ);

    // Hadamard on all qubits
    for i in 0..n 
    {
        x[i]:=H(x[i]);
    }

    val:=0:ùîπ;
    reps:=1;
    beta:= 2*betas[0];
    gamma:= 2*gammas[0];

    for rep in [0..reps)
    {
        // Apply problem unitary. Tag each neighboring node with a Z rotation
        for i in [0..n_graph_edges)
        {
            edge:=g_edges[i];
            node1:=edge[0];
            node2:=edge[1];

            // Apply CNOT RZ on x[node2] if x[node1] is 1
            // NOTE: Need to swap x[node1] to a temp register since we cannot consume the state
            (val, x[node1]):=(x[node1], val);
            if val
            {
                x[node2]:=X(x[node2]);
                x[node2]:=rotZ(gamma, x[node2]);
                x[node2]:=X(x[node2]);
            }
            // Swap back
            (x[node1], val):=(val, x[node1]);
        }

        // Apply mixer unitary
        for i in [0..n)
        {
            // Apply Rx for our betas
            x[i]:=rotX(beta, x[i]);
        }
    }

    forget(val=0);
    return x;
}

def main()
{
    return QAOA[n](graph, betas, gammas);
}
